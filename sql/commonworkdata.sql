-- phpMyAdmin SQL Dump
-- version 4.7.4
-- https://www.phpmyadmin.net/
--
-- Anamakine: 127.0.0.1
-- Üretim Zamanı: 11 Mar 2019, 23:44:28
-- Sunucu sürümü: 10.1.26-MariaDB
-- PHP Sürümü: 7.1.9

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Veritabanı: `commonworkdata`
--

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `haftalikyayin`
--

CREATE TABLE `haftalikyayin` (
  `konuid` int(11) NOT NULL,
  `konu` text COLLATE utf8_turkish_ci NOT NULL,
  `kisabaslik` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `yayinTarih` varchar(50) COLLATE utf8_turkish_ci NOT NULL,
  `paytur` varchar(30) COLLATE utf8_turkish_ci NOT NULL,
  `yazar` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `yazarId` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `haftalikyayin`
--

INSERT INTO `haftalikyayin` (`konuid`, `konu`, `kisabaslik`, `yayinTarih`, `paytur`, `yazar`, `yazarId`) VALUES
(21, '<h3><strong>Kaos Teorisi nedir. ?</strong></h3>\r\n\r\n<p><strong>Kaos teorisi</strong>,&nbsp;<strong>kaos</strong>&nbsp;kuramı matematiksel t&uuml;mevarım yada fiziksel teori değil , fiziksel ger&ccedil;eklik par&ccedil;alarının bir b&uuml;t&uuml;n olarak eğilimini a&ccedil;ıklamaya yarayan bir y&ouml;ntemdir.</p>\r\n\r\n<p>&nbsp;&nbsp;<img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/6cefb43.jpeg\" style=\"height:250px; width:400px\" /></p>\r\n\r\n<p><strong>Var Olduğumuz Evren ile Kaos arasındaki ilişki nedir ?</strong></p>\r\n\r\n<p><strong>Acaba i&ccedil;inde yaşadığımız ve kusursuz g&ouml;rd&uuml;ğ&uuml;m&uuml;z Evren Kaostan mı ibaret.?</strong></p>\r\n\r\n<p>Yaratıcı&#39;nın varlığını kanıtlamak i&ccedil;in en &ccedil;ok başvurulan yollardandır &quot;<strong>bu m&uuml;kemmel sistem kendiliğinden oluşmuş olabilir mi&quot;</strong>&nbsp;sorusu. d&uuml;nyanın ve de evrenin m&uuml;kemmel bir dengesi vardır ve de en ufak bir hatada bu denge alt &uuml;st olabilir oysa b&ouml;yle bir hata olmadığı i&ccedil;in her şey yolunda .B&uuml;t&uuml;n bu d&uuml;zeni yaratan bir yaratıcı&nbsp;olmasaydı ortada denge değil &quot;kaos&quot; olurdu.</p>\r\n\r\n<p>&Ccedil;evremizi incelediğimizde şu soruyu&nbsp;&nbsp;sormamız gerekmez mi ; Bu evren rasgele oluşmuş olabilir mi ?</p>\r\n\r\n<p><strong>B&uuml;y&uuml;k Patlama,</strong>&nbsp;<em>evreni ve i&ccedil;indekileri</em>&nbsp;var eden olaydır. Ge&ccedil;mişimizin sırları bug&uuml;n&uuml;m&uuml;z ve geleceğimiz. Zaman i&ccedil;erisindeki bu &ccedil;ok &ouml;zel an ile ilintilidir.&nbsp;<em>B&uuml;y&uuml;k Patlamanın sırlarını</em>&nbsp;aralayabilmemiz i&ccedil;in&nbsp;<em>G&uuml;neş Sisteminin dışına</em>&nbsp;&ccedil;ıkmamız ve hatta&nbsp;<em>galaksimizin de &ouml;tesine</em>&nbsp;uzanmamız gerekir.&nbsp;<em>İlk ortaya &ccedil;ıkan galaksilerin ve yıldızların da &ouml;tesine.</em>&nbsp;<em>Evrenin ilk başladığı ana</em>&nbsp;uzanın ve bilim tarafından ortaya konan en b&uuml;y&uuml;k soru ile y&uuml;zleşin. Bu&nbsp;<em>fiziğin en b&uuml;y&uuml;k sorusu.</em>&nbsp;<em>Neden patladığını &ouml;ğrenmek istiyoruz. Neyin patladığını &ouml;ğrenmek istiyoruz. Patlamadan &ouml;nce neyin olduğunu &ouml;ğrenmek istiyoruz.</em></p>\r\n\r\n<p><strong>Bilim insanları</strong>&nbsp;t&uuml;m bu cevapları bulmak i&ccedil;in&nbsp;<em>şehirler b&uuml;y&uuml;kl&uuml;ğ&uuml;nde cihazlar</em>&nbsp;inşa etti.&nbsp;<em>Evrenin başlangıcındaki durumunu sim&uuml;le etmek i&ccedil;in.</em>&nbsp;<em>Ve de uzayın derinliklerine bakabilmek i&ccedil;in dev teleskoplar.</em>&nbsp;Şimdilerde t&uuml;m bu soruları cevaplamaya daha da yaklaştık.&nbsp;<em>Evrenin bir başlangıcı ve de bir sonu var mı? Cevabı evet ise, nasıl?</em></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', 'Evren Rastgele mi Oluştu ? (Kaos ve Evren İlişkisi)', '13 Şubat 2019', '', 'emreaydin', 2),
(22, '<h3><strong>&Ouml;ğrenme Kabiliyetinin&nbsp;Mantığı</strong></h3>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Merkezi sinir sisteminin en &ouml;nemli kısmı olan beynin işlev g&ouml;rmesi, h&uuml;creler arasındaki iletişim ile ger&ccedil;ekleşir. Sinir(n&ouml;ron) h&uuml;creleri ve glial (glue) h&uuml;creler olmak &uuml;zere iki t&uuml;r h&uuml;crenin bulunduğu insan beyninde, yaklaşık 1 trilyon h&uuml;cre vardır. Sinir sistemi ve beyin fonksiyonlarının ana &ouml;ğeleri olan n&ouml;ronlar, h&uuml;cre g&ouml;vdesi, dendrit ve akson olmak &uuml;zere &uuml;&ccedil; kısımdan oluşur.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;<img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/7530ac7.jpg\" style=\"height:227px; width:400px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Şekil 1. Basit bir sinir h&uuml;cresi(N&ouml;ron)</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dendrit&#39;ler h&uuml;creye gelen girişleri toplarlar. Dendrit tarafından alınan işaretler h&uuml;cre g&ouml;vdesinde birleştirilerek bir &ccedil;ıkış darbesi &uuml;retilip &uuml;retilemeyeceğine karar verilir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Eğer bir iş yapılacaksa &uuml;retilen &ccedil;ıkış darbesi aksonlar tarafından taşınarak diğer n&ouml;ronlarla olan bağlantılara iletilir. Bir n&ouml;ronun &ccedil;ıkışı ona bağlı olan b&uuml;t&uuml;n n&ouml;ronlara iletilir. N&ouml;ronlar arasındaki bağlantılar h&uuml;cre g&ouml;vdesinde veya &quot;sinaps&quot; adı verilen dendritlerdeki ge&ccedil;işlerde olur.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Beyinde bilginin &ouml;ğrenilmesi ve saklanması sinir h&uuml;creleri arasında elektriksel ve kimyasal sinyallerle oluşur (Wolfe, 2001). N&ouml;ronlar elektrik sinyalini h&uuml;cre duvarındaki voltajı değiştirerek &uuml;retirler. Bu ise h&uuml;crenin i&ccedil;inde ve dışında dağılmış bulunan iyonlar vasıtasıyla olur. İnsan beyni bu şekilde &ccedil;alışan milyonlarca n&ouml;ronun bir araya gelmesinden oluşur.</p>\r\n', 'Beyin ve Öğrenme ', '13 Şubat 2019', '', 'emreaydin', 2);

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `icerik`
--

CREATE TABLE `icerik` (
  `icerikID` int(11) NOT NULL,
  `icerikSayfaAd` varchar(150) COLLATE utf8_turkish_ci NOT NULL,
  `icerikFoto` varchar(255) COLLATE utf8_turkish_ci NOT NULL,
  `icerikIcBaslik` varchar(150) COLLATE utf8_turkish_ci NOT NULL,
  `icerikAciklama` varchar(255) COLLATE utf8_turkish_ci NOT NULL,
  `icerik` text COLLATE utf8_turkish_ci NOT NULL,
  `icerikTarih` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `yazar` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `yazarId` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `icerik`
--

INSERT INTO `icerik` (`icerikID`, `icerikSayfaAd`, `icerikFoto`, `icerikIcBaslik`, `icerikAciklama`, `icerik`, `icerikTarih`, `yazar`, `yazarId`) VALUES
(27, 'Veri Yapıları (Data Structures)', '2-icerik76925-74640', 'Yığınlar ve Kuyruklar', 'Yığınlar ve Kuyruklar önceden belirlenmiş bir DELETE işlemi ile elemanları kümeden silinebilen  dinamik kümelerdir.', '<p>Bir Yığında k&uuml;meden silinecek eleman daima k&uuml;meye eklenen son elemandır : Yığınlar <strong>&quot;son giren , ilk &ccedil;ıkar&nbsp;(LIFO)&quot; </strong>politikasını uygular.Benzer bi&ccedil;imde Kuyrukta k&uuml;meden silinecek eleman dai&ouml;a k&uuml;meye ilk giren elemandır.: Dolayısıyla<strong> kuyruk</strong> veri yapılarında&nbsp;ise &quot;ilk giren , ilk &ccedil;ıkar&quot; politikası uygulanır. Yığın ve Kuyruk veri yapılarını etkin bir şekilde kodlamak m&uuml;mk&uuml;nd&uuml;r.</p>\r\n\r\n<h3><strong>YIĞINLAR</strong></h3>\r\n\r\n<p>Bir Yığın &uuml;zerinde INSERT işlemi PUSH ve herhangi bir parametre almayan DELETE işlemi ise POP olarak adlandırılır. Bu işlemin ger&ccedil;ek hayatta ki karşılığı &ccedil;eyiz sandığı mantığıdır yani &ccedil;eyiz sandığına ilk koyduğumuz eşya sandık boşaltılırken sandıktan en son &ccedil;ıkar. Buna paralel olarak ilk koyduğumuz eşye ilk &ccedil;ıkmış olur.</p>\r\n\r\n<p>Şekil 1 de g&ouml;rd&uuml;ğ&uuml;m&uuml;z gibi &nbsp;<strong>n </strong>elemanlı stack adında bir yığını <strong>stack[1...n]</strong> şeklinde ifade edebiliriz.</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/1025bee4.png\" style=\"height:102px; width:443px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Şekil 1 Yığına veri Ekleme durumu</p>\r\n\r\n<p>Durum 1: stack.bas=3 yani Yığına 9 eklendiğinde baştaki eleman 3. indisteki elemana eşitlenir. &#39;&nbsp;<strong>PUSH(stack,9)&nbsp;</strong>&#39; fonksiyonu aktif olur.</p>\r\n\r\n<p>Durum 2: stack.bas=4 yani aynı şekilde&nbsp;Yığına 73&nbsp;eklendiğinde baştaki eleman 4. indisteki elemana eşitlenir. &#39;&nbsp;<strong>PUSH(stack,73)&nbsp;</strong>&#39; fonksiyonu aktif olur.</p>\r\n\r\n<p>Yığının en alttaki elemanı stack[1] ve Yığının en &uuml;stteki elemanı stack[stack.bas] olur. stack.bas=0 olduğunda yığın hi&ccedil; bir eleman i&ccedil;ermez ve boş olarak adlandırılır. Yığının boş olup olmadığını StackEmpty Fonksiyonu ile kontrol edebiliriz.</p>\r\n\r\n<p>Yığının boş olup olmadığını StackEmpty Fonksiyonu:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">bool StackEmpty(stack)\r\n{\r\n  if(stack.bas==0){\r\n     \r\n     return true;\r\n       }\r\n  else {\r\n     return false;\r\n       }\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Yığını doldurmak i&ccedil;in kullandığımız PUSH fonksiyonu :</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">int PUSH(stack,x) // x -&gt; eklenmek istenen değer.\r\n{\r\n  stack.bas=stack+1; \r\n  stack[stack.bas]=x;\r\n  \r\n\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Yığından değer silmek i&ccedil;in kullandığımız POP fonksiyonu :</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">int POP(stack)\r\n{\r\n   if(StackEmpty){ // öncelikle yığının boş olup olmadığını kontrol edilir.\r\n\r\n    return (-1); //yığın boşken eleman silinmeye çalışılırsa hata oluşur.\r\n\r\n   }\r\n   else {\r\n         stack.bas=stack.bas-1;\r\n         return stack[stack.bas+1];\r\n       \r\n        }\r\n}</code></pre>\r\n\r\n<h3>&nbsp;</h3>\r\n\r\n<h3><strong>KUYRUKLAR</strong></h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Kuyruğa INSERT işlemi&nbsp; EQUEUE ve kuyruktan DELETE işlemi DEQUEUE&nbsp; ile ger&ccedil;ekleştirilir. Yığın veri yapısındaki&nbsp;&nbsp;POP işlemimnde&nbsp;&nbsp;olduğu gibi DEQUEUE işlemi herhangi bir parametre almaz. Kuyruk veri yapısı banka atm sırasında para &ccedil;ekmek i&ccedil;in bekleyen m&uuml;şterilere benzetilebilir.Kuyruk yapısı başlık ve kuyruk niteliklerine sahiptir. Kuyruğa bir eleman ekleneceği zaman ekleme işlemi kuyruğun sonuna yapılır. Kuyruktan eleman &ccedil;ıkarılacağı zaman ise &ccedil;ıkarma işlemi kuyruğun başından yapılır.</p>\r\n\r\n<p>Q.bas kuyruğa eklenen ilk elemanı belirtir. Q.son ise kuyruğa eklenen son elemanı belirtir.Kuyruğun elemanları dizinin Q.bas , Q.bas-1,...,Q.son-1 indislerinde konumlanır.</p>\r\n\r\n<p>EQUEUE Fonksiyonu :&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">int EQUEUE(Q,x)\r\n{\r\n  Q[Q.son]=x;\r\n  if(Q.son==Q.length){  \r\n      \r\n      Q.son=1;\r\n     }\r\n  else {\r\n\r\n   Q.son=Q.son+1;\r\n       }\r\n \r\n}</code></pre>\r\n\r\n<p>DEQUEUE Fonksiyonu :&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">int DEQUEUE(Q)\r\n{\r\n  x=Q[Q.bas];\r\n  if(Q.bas==Q.length){  \r\n      \r\n      Q.bas=1;\r\n     }\r\n  else {\r\n\r\n   Q.bas=Q.bas+1;\r\n       }\r\n return x;\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n', '14 Şubat 2019', 'emreaydin', 2),
(28, 'Veri Yapıları (Data Structures)', '2-icerik82618-56249', 'BAĞLI LİSTELER (LİNKED LIST)', 'Bağlı listeler , nesnelerin doğrusal bir sırada , bir dizinin aksine dizinin indisi ile değil de her bir nesneyi gösteren işaretçilerle belirlenir.', '<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Birden fazla Bağlı liste t&uuml;r&uuml; bulunmaktadır. Bunlardan &Ccedil;ift Y&ouml;nl&uuml; bağlı <strong>linledlist&nbsp;</strong>listesinin her bir elemanı key niteliği ile birlikte <strong>prev</strong> ve <strong>next</strong>&nbsp; işaret&ccedil;ilerine sahiptir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Listeye bir x elemanı eklendiğinde&nbsp; <strong>x.next</strong> x elemanından sonra gelen nesneyi işaret ediyor demektir aynı şekilde&nbsp;<strong> x.prev </strong>niteliği ise x&nbsp; elemanından &ouml;nce gelen nesneyi işaret etmektedir. Eğer <strong>x.prev=NULL</strong>&nbsp; ise x linkedlist listesinin başındaki elemandır. Eğer x.next=NULL ise x in ardılı yok demektir. Bundan dolayı x listenin son elemanı yani kuyğudur.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lindedlist.bas niteliği listenin baştaki elemanını g&ouml;sterir. Eğer linkedlist.bas=NULL ise liste boştur. Bir liste tek y&ouml;nl&uuml; veya &ccedil;ift y&ouml;nl&uuml; , sıralı veya sırasız, dairesel veya dairesel olmayan gibi farklı formlara sahip olabilir. Eğer liste tek başına bağlı ise yani tek t&ouml;nl&uuml; ise listenin prev &ouml;zelliği olmaz. Eğer liste sıralı ise elemanların listeye yerleştirilmesi elemanların kendi araarındaki diziliş durumuyla ilintilidir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Anahtar litelik değerinin minimum olduğu eleman listenin başına anahtar nitelik değerinin maksimum olduğu eleman listenin sonuna eklenir. Eğer liste sırasız ise elemanlar herhangi bir sıra g&ouml;etilmeksizin listeye yerleştirilir. Bir dairesel listede listenin başındaki elemanın prev niteliği listenin sonundaki elemanı g&ouml;sterir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Benzer şekilde listenin son elemanının next niteliği listenin baştaki elemanını g&ouml;sterir.&nbsp;Burada &ccedil;alıştığımız ve &ouml;rneklerini verdiğim Şekil 1 de g&ouml;t&uuml;ld&uuml;ğ&uuml; gibi liste t&uuml;r&uuml; &ccedil;ift y&ouml;nl&uuml; bağlı liste olacaktır.&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/11f20977.png\" style=\"height:125px; width:613px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Şekil 1.&nbsp; &Ouml;rnek &ccedil;ift y&ouml;nli bağlı liste veri yapısı</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Bu Veri Yapısının C dilindeki karşılığı :</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\nstruct Node {     // Liste üzerinde ekleme ve güncelleme yapmak için bu \r\n                 //  yapıyı kullanarak düğüm yapısı oluşturuyoruz.\r\n                \r\n	int data;\r\n	Node* next=NULL;\r\n};\r\n\r\nstruct Node * Start =NULL;\r\nstruct Node * Temp=NULL;\r\n\r\n//Listenin sonuna eklemek için.       \r\nvoid insertLast(int info) // Bu fonksiyon info parametresini alıp oluşturulan\r\n                          // düğümün data niteliğine atamasını yapıyor.                       \r\n{\r\n	Node * item=(Node *)malloc(sizeof(Node));\r\n	item-&gt;data=info;\r\n	item-&gt;next=NULL;\r\n	if(Start==NULL)\r\n	{\r\n		Start=item;\r\n	}\r\n	else\r\n	{\r\n		Temp=Start;\r\n		while(Temp-&gt;next!=NULL)\r\n		{\r\n			Temp=Temp-&gt;next;\r\n		}\r\n		Temp-&gt;next=item;\r\n		\r\n	}\r\n	\r\n}\r\n//Listenin Başına Eklemek için.\r\nvoid insertHead(int info)\r\n{\r\n	Node * item=(Node *)malloc(sizeof(Node));\r\n	item-&gt;data=info;\r\n	item-&gt;next=NULL;\r\n	\r\n	if(Start==NULL)\r\n	{\r\n		Start=item;\r\n	}\r\n	else\r\n	{\r\n		item-&gt;next=Start;\r\n		Start=item;\r\n	}\r\n	\r\n}\r\n//Listenin Ortasına eklemek için.\r\nvoid insertMiddle(int info,int location)\r\n{\r\n	Node * item =(Node * )malloc(sizeof(Node));\r\n	item-&gt;data=info;\r\n	item-&gt;next=NULL;\r\n	\r\n	if(Start==NULL)\r\n	{\r\n		Start=item;\r\n	}\r\n	else\r\n	{\r\n		Temp=Start;\r\n		while(Temp-&gt;next-&gt;data!=location)\r\n		{\r\n			Temp=Temp-&gt;next;\r\n		\r\n		}\r\n		item-&gt;next=Temp-&gt;next;\r\n		Temp-&gt;next=item;\r\n	\r\n	}\r\n}\r\n\r\n//Listede silme işlemi \r\n//-------------------------------------------\r\n//Listenin ortasından eleman silmek için önce\r\n//listede o eleman bulunana kadar dolaşmamız gerekiyor.\r\n\r\nvoid middleDelete(int info) //Ortadan eleman silme fonksiyonu\r\n{\r\n	\r\n	if(Start==NULL)\r\n	{\r\n		printf(\"linkedList is NULL\");\r\n	}\r\n	else\r\n	{\r\n		\r\n		if(Start-&gt;data==info)\r\n		{\r\n			Start=Start-&gt;next;\r\n		}\r\n		else\r\n		{\r\n			Temp=Start;\r\n			while(Temp-&gt;next-&gt;data!=info)\r\n			{\r\n				Temp=Temp-&gt;next;\r\n			}\r\n			Temp-&gt;next=Temp-&gt;next-&gt;next;\r\n		}\r\n		\r\n		\r\n	}\r\n	\r\n	\r\n	\r\n}\r\n\r\nvoid headDelete()     //Baştan eleman silme fonksiyonu\r\n{\r\n	if(Start==NULL)\r\n	{\r\n		printf(\"LinkedList is NULL!!\");\r\n		\r\n	}\r\n	else\r\n	{\r\n		Start=Start-&gt;next;\r\n	}\r\n\r\n}\r\n\r\nvoid LastDelete()      //Sondan eleman silme işlemi\r\n{\r\n	\r\n	if(Start==NULL)\r\n	{\r\n		printf(\"LinkedList is NULL\");\r\n		\r\n	}	\r\n	else \r\n	{\r\n		Temp=Start;\r\n		while(Temp-&gt;next-&gt;next!=NULL)\r\n		{\r\n					\r\n			Temp=Temp-&gt;next;					\r\n			\r\n		}\r\n		Temp-&gt;next=NULL;\r\n		\r\n	}\r\n	\r\n	\r\n}\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n', '14 Şubat 2019', 'emreaydin', 2),
(29, 'Veri Yapıları (Data Structures)', '2-icerik89026-83314', 'HASHING', 'Elimizdeki veriyi kullanarak , elimizden geldiği kadar benzersiz bir tam sayı elde etme işlemidir.', '<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Elde etmeye &ccedil;alıştığımız bu tamsayı, dizi şeklinde tutulan verilerin indisi gibi kullanılarak verilere tek seferde yani O(1) zamanda erişim olanağı sunar.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arama metotlarında temel işlem anahtarları karşılaştırmaktır. Bir anahtarın tablo i&ccedil;erisinde yeri bulunduğu pozisyona ulaşıncaya kadar arama işlemine devam edilir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hash fonksiyonuyla aranan anahtar elemana doğrudan erişebilmektedir. Hash fonksiyonu bir anahtar bilgisinin tabloda bulunduğu indeksi hesaplamaktadır.</p>\r\n\r\n<p>Boyutu N olan bir tabloda , hash fonksiyonu (h(x)) bir x anahtarını 0 ile N-1 arasında bir değerle eşleştirir.</p>\r\n\r\n<p>&Ouml;rnek :</p>\r\n\r\n<p>N= 15 olan bir tablo i&ccedil;in h(x)=x%15 olarak belirlenebilir.</p>\r\n\r\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\r\n	<tbody>\r\n		<tr>\r\n			<td>x</td>\r\n			<td>53</td>\r\n			<td>132</td>\r\n			<td>2351</td>\r\n			<td>897</td>\r\n			<td>129</td>\r\n			<td>36</td>\r\n		</tr>\r\n		<tr>\r\n			<td>h(x)</td>\r\n			<td>8</td>\r\n			<td>12</td>\r\n			<td>11</td>\r\n			<td>12</td>\r\n			<td>9</td>\r\n			<td>6</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; Tablo 1 -&nbsp;&nbsp;x değerlerinin mod 15 &#39;e g&ouml;re indisleri.</p>\r\n\r\n<p>Tablo 1 &#39;de g&ouml;r&uuml;ld&uuml;ğ&uuml; gibi gelen x değerinin mod 15 e g&ouml;re indisleri belirlendi.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px\">\r\n	<tbody>\r\n		<tr>\r\n			<td>0</td>\r\n			<td>1</td>\r\n			<td>2</td>\r\n			<td>3</td>\r\n			<td>4</td>\r\n			<td>5</td>\r\n			<td>6</td>\r\n			<td>7</td>\r\n			<td>8</td>\r\n			<td>9</td>\r\n			<td>10</td>\r\n			<td>11</td>\r\n			<td>12</td>\r\n			<td>13</td>\r\n			<td>14</td>\r\n		</tr>\r\n		<tr>\r\n			<td>-</td>\r\n			<td>-</td>\r\n			<td>-</td>\r\n			<td>-</td>\r\n			<td>-</td>\r\n			<td>-</td>\r\n			<td>36</td>\r\n			<td>-</td>\r\n			<td>53</td>\r\n			<td>129</td>\r\n			<td>-</td>\r\n			<td>2351</td>\r\n			<td>897</td>\r\n			<td>-</td>\r\n			<td>-</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Tablo 2 -&nbsp;Verilerin tablo i&ccedil;erindeki indise g&ouml;re konumları</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/13a07e56.png\" style=\"height:338px; width:592px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Şekil 1 Keylere sahip kayıtların hash fonksiyonu sonucu.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Asıl &ouml;nemli olan soru şu eğer değerler bir şekilde aynı gelirse fonksiyon ne yapar ?</p>\r\n\r\n<p>İşte bu sorunun &ccedil;&ouml;z&uuml;m&uuml; i&ccedil;in bir&ccedil;ok Hash fonksiyonu var.</p>\r\n\r\n<p>1. &ccedil;&ouml;z&uuml;m yolu: <strong>Rakam se&ccedil;me (Selecting Digit)&nbsp;</strong></p>\r\n\r\n<ul>\r\n	<li>Anahtar &uuml;zerindeki belirlenmiş bazı haneleri se&ccedil;ip birleştirerek tabloda&nbsp; pozisyon bulur.</li>\r\n	<li>&ouml;rn: h(235648)=34 (1. ve 4. haneleri birleştirdi)</li>\r\n	<li>Bu fonksiyon &nbsp;hızlıdır ve yapısı basittir ancak anahtarın tamamını tabloda d&uuml;zg&uuml;n dağıtamaz.</li>\r\n	<li>&Ccedil;akışma sık yaşanır.</li>\r\n</ul>\r\n\r\n<p>2.&Ccedil;&ouml;z&uuml;m Yolu : <strong>Katlama (Folding)</strong></p>\r\n\r\n<ul>\r\n	<li>Anahtar birka&ccedil; par&ccedil;aya b&ouml;l&uuml;n&uuml;r ve bu par&ccedil;alar kendi arasında toplanır ve tablodaki pozisyon bulunur.</li>\r\n	<li>Shift Folding metodunda anahtarın herbir par&ccedil;ası değiştirilmeden tablo boyutuna g&ouml;re mod ile toplanır.</li>\r\n	<li>&ouml;rn: sayı - &gt;123-456-789 olarak verilsin bu toplandığında 123+456+789=1368 ile pozisyon no bulunur.</li>\r\n</ul>\r\n\r\n<p>3.&Ccedil;&ouml;z&uuml;m Yolu : <strong>B&ouml;lme(Division)</strong></p>\r\n\r\n<ul>\r\n	<li>Anahtar değeri tablo boyutuna g&ouml;re mod ile b&ouml;l&uuml;n&uuml;r.</li>\r\n	<li>&ouml;rn: boyut 8645745 olarak verilsin. Tablo boyutu 100 olursa,</li>\r\n	<li>hash fonksiyonu - &gt; hash(h)=8645745%100=45 olur.</li>\r\n	<li>&Ccedil;akışma yaşanır.</li>\r\n</ul>\r\n\r\n<p>G&ouml;r&uuml;ld&uuml;ğ&uuml; &uuml;zere buraya kadar incelediğimiz &ccedil;&ouml;z&uuml;m metodlarında verilerin yerleştirilmesinde &ccedil;akışma riski bulunmakta,&nbsp;bu &ccedil;akışma durumunu ortadan kaldırmayı ama&ccedil;layan fonksiyonlarda mevcuttur.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3><strong>Chaning Metodu</strong></h3>\r\n\r\n<p>Aynı pozisyona gelen kayıtlar bağlı liste y&ouml;ntemi kullanılarak o pozisyona bağlanır.</p>\r\n\r\n<p>listeye ekleme hep baştan olur.Silme ve Erişim ise listede aramalar yapılarak ger&ccedil;ekleştirilir.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/14dcf6b7.png\" style=\"height:215px; width:400px\" /><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/15b4e7c4.png\" style=\"height:264px; width:270px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Şekil 2 - Chaning Fonksiyonu</p>\r\n\r\n<p>Bu metotda bağlı listeler uzadık&ccedil;a arama ve silme işlemleri i&ccedil;in gerek zaman uzamaktadır.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3><strong>Lineer Probing Metodu</strong></h3>\r\n\r\n<ul>\r\n	<li>Bu metotda bağlı listeler gibi ayrı bir veri yapısına ihtiya&ccedil; duyulmaz.</li>\r\n	<li>Kayıtların yığın şekilde toplanmasına sebep olur.</li>\r\n	<li>Silme ve aram işlemleri i&ccedil;in gereken zaman hash değeri arttık&ccedil;a artar.</li>\r\n</ul>\r\n\r\n<p>Gelen verileri tablo boyutuna mod layarak taploya yerleştirir.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '15 Şubat 2019', 'emreaydin', 2);

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `iletisimkullanici`
--

CREATE TABLE `iletisimkullanici` (
  `mesID` int(11) NOT NULL,
  `isim` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `eposta` varchar(150) COLLATE utf8_turkish_ci NOT NULL,
  `mesaj` text COLLATE utf8_turkish_ci NOT NULL,
  `durum` int(11) NOT NULL DEFAULT '0',
  `mesTarih` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `yazarId` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `iletisimkullanici`
--

INSERT INTO `iletisimkullanici` (`mesID`, `isim`, `eposta`, `mesaj`, `durum`, `mesTarih`, `yazarId`) VALUES
(11, 'Burak ', 'burakyazici1296@hotmail.com', 'emre ramazan', 1, '15 Ocak 2019', 1),
(12, 'Eray', 'yesil@gmail.com', 'Eray yeşilyurt', 0, '16 Ocak 2019', 6),
(14, 'berivan', '16541553@firat.edu.tr', 'emre', 1, '16 Ocak 2019', 1),
(15, 'Tarık ', 'tarik.@gmail.com', '536', 1, '10 Şubat 2019', NULL),
(16, 'asdasd', 'omertuygun93@gmail.com', '<script>alert(\"213\")</script>', 0, '17 Şubat 2019', NULL),
(17, '<script>alert(\"213\")</script>', 'asdasd@asdasd', '<script>alert(\"213\")</script>', 0, '17 Şubat 2019', NULL);

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `kullanicilar`
--

CREATE TABLE `kullanicilar` (
  `kulid` int(11) NOT NULL,
  `ad` varchar(50) COLLATE utf8_turkish_ci NOT NULL,
  `soyad` varchar(50) COLLATE utf8_turkish_ci NOT NULL,
  `fotograf` varchar(300) COLLATE utf8_turkish_ci NOT NULL,
  `eposta` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `kullaniciAdi` varchar(60) COLLATE utf8_turkish_ci NOT NULL,
  `hakkimda` text COLLATE utf8_turkish_ci NOT NULL,
  `parola` varchar(50) COLLATE utf8_turkish_ci NOT NULL,
  `yetki` int(5) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `kullanicilar`
--

INSERT INTO `kullanicilar` (`kulid`, `ad`, `soyad`, `fotograf`, `eposta`, `kullaniciAdi`, `hakkimda`, `parola`, `yetki`) VALUES
(2, 'EMRE', 'AYDIN', '2-profil67711-5424', 'emre@gmail.com', 'emreaydin', '<p><strong>Merhaba , &Ouml;ncelikle kısa &ouml;zge&ccedil;mişimden bahsetmek istiyorum ;</strong></p>\r\n\r\n<p>Bursa&#39;da doğdum ve b&uuml;y&uuml;d&uuml;m. İlk,orta ve lise eğitimimi Bursa&#39;da tamamladım ve şuan da Fırat &Uuml;niversitesinde lisans eğitimi almaktayım.</p>\r\n\r\n<p>Fırat &Uuml;niversitesi Yazılım M&uuml;hendisliği 3. Sınıf &Ouml;ğrencisiyim , M&uuml;hendisliğin doğasında var olan,&nbsp; disiplin , kalite ve tekrarlanabilir başarıyı hedefde tutarak ilerlemek en b&uuml;y&uuml;k vizyonumdur.</p>\r\n\r\n<p>Nesne Y&ouml;nelimli ve kural tabanlı sistemler &uuml;zerinde yoğunlaşmış bulunmaktayım.</p>\r\n\r\n<p>Bu doğrultuda&nbsp;bilgi paylaşımına a&ccedil;ığım 7/24 online birisiyim , iletişim sekmesinden yada doğrudan aşağıdaki mail&#39;den bana ulaşabilirsiniz. Teşekk&uuml;r ederim.</p>\r\n\r\n<p>E-Posta :emramzn@gmail.com</p>\r\n', 'emre66', 1);

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `menusayfalari`
--

CREATE TABLE `menusayfalari` (
  `sayfaid` int(11) NOT NULL,
  `menuSayfaAd` varchar(50) COLLATE utf8_turkish_ci NOT NULL,
  `menuSayfaTarih` datetime NOT NULL,
  `menuSayfaIcerikSayi` int(11) NOT NULL,
  `yazar` varchar(50) COLLATE utf8_turkish_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `menusayfalari`
--

INSERT INTO `menusayfalari` (`sayfaid`, `menuSayfaAd`, `menuSayfaTarih`, `menuSayfaIcerikSayi`, `yazar`) VALUES
(3, 'Veri Yapıları (Data Structures)', '0000-00-00 00:00:00', 0, 'emreaydin');

-- --------------------------------------------------------

--
-- Tablo için tablo yapısı `muhsekme`
--

CREATE TABLE `muhsekme` (
  `icerikId` int(11) NOT NULL,
  `icerikfoto` varchar(255) COLLATE utf8_turkish_ci NOT NULL,
  `icerikbaslik` varchar(200) COLLATE utf8_turkish_ci NOT NULL,
  `aciklama` varchar(250) COLLATE utf8_turkish_ci NOT NULL,
  `icerik` text COLLATE utf8_turkish_ci NOT NULL,
  `tarih` varchar(30) COLLATE utf8_turkish_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;

--
-- Tablo döküm verisi `muhsekme`
--

INSERT INTO `muhsekme` (`icerikId`, `icerikfoto`, `icerikbaslik`, `aciklama`, `icerik`, `tarih`) VALUES
(2, '2-icerik52119-94382', 'Yazılım Geliştirme Yaşam Döngüsü (Software Development Life Cycle )', 'Üçüncü sınıf öğrencisi olarak  hala tekrar tekrar gördüğümüz  bir Yazılım geliştirme sürecinin yönetimini ifade eden  süreç yaklaşımı.', '<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Aslında temel olarak d&uuml;ş&uuml;nd&uuml;ğ&uuml;m&uuml;zde sadece yazılım geliştirme s&uuml;recinin y&ouml;netime, belli bir disipline ve &ouml;nceden belirlenmiş aşamalarla kontrol edilebilir bir yapıya ihtiyacı yoktur. Eğer bir sistem geliştirilecek ve kullanıma sunulacaki se bu sistem az maliyetli, y&uuml;ksek kaliteli ve belirlenen zaman aralığında belli bir y&ouml;netim modeliyle ortaya konulmalıdır.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;İşte tam da bu noktada M&uuml;hendislik yaklaşımı devreye giriyor. Eğer maliyet ,&nbsp;zaman&nbsp; ve belli gereksinimler doğrultusunda bir sistem oluşturulacak ise M&uuml;hendislik yaklaşımı bu sistemin &uuml;retim s&uuml;recini , Kalite ve y&ouml;netim parametrelerini ele alarak&nbsp; tekrarlanabilir başarıyı hedefleyerek &uuml;retim s&uuml;recini idame ettirir.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Yazılımın &uuml;r&uuml;n&uuml;n&uuml;n hem &uuml;retim hem de m&uuml;şterideki kullanım s&uuml;reci boyunca ge&ccedil;irdiği t&uuml;m aşamalar yazılım geliştirme yaşam d&ouml;ng&uuml;s&uuml; (&ldquo;software development life cycle&rdquo;, &ldquo;SDLC&rdquo;) olarak adlandırılır. Yazılım geliştirme s&uuml;reci, zamanlamaya dayalı ve i&ccedil;erik olarak b&ouml;l&uuml;nm&uuml;ş aşamalardan oluşmaktadır.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bu sayede yazılım planlı bir şekilde geliştirilmektedir. Yazılım işlevleri ile ilgili gereksinimler s&uuml;rekli olarak değiştiği ve genişlediği i&ccedil;in, s&ouml;z konusu aşamalar s&uuml;rekli bir d&ouml;ng&uuml; bi&ccedil;iminde ele alınır. D&ouml;ng&uuml; i&ccedil;erisinde her hangi bir aşamada geriye d&ouml;nmek ve tekrar ilerlemek s&ouml;z konusudur. Temel yazılım geliştirme aşamaları aşağıdaki gibidir:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/9724a4c.gif\" style=\"height:305px; width:300px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Şekil 1 SDLC genel S&uuml;reci</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li><strong>Planlama:</strong>&nbsp;Yazılım yaşam d&ouml;ng&uuml;s&uuml;n&uuml;n ilk aşamasıdır. Temel ihtiya&ccedil;lar belirlenir, proje i&ccedil;in&nbsp;<strong>fizibilite&nbsp;</strong>&ccedil;alışmaları yapılır (maliyetlerin ve sistemin yararlarının tanımlanması) ve proje planlaması ger&ccedil;ekleştirilir.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li><strong>Analiz:</strong>&nbsp;Bu aşamanın amacı sistemin işlevlerini ve kesin gereksinimleri a&ccedil;ıklığa kavuşturmak ve sonucunda bunları belirli bir formatta&nbsp;<strong>dok&uuml;mante</strong>&nbsp;etmektir. Bu &ccedil;alışma m&uuml;şteri, yazılım m&uuml;hendisi, sistem analisti, iş analisti, &uuml;r&uuml;n y&ouml;neticisi vb. rollerin bir araya geldiği gruplar tarafından yapılabilir. İhtiya&ccedil;ların net olmadığı durumlarda yazılım m&uuml;hendisi ve m&uuml;şteri arasında iletişim ve birlikte &ccedil;alışmanın &ccedil;ok daha fazla olması gerekir. &Ccedil;eşitli yazılım geliştirme metodolojilerinde bu aşamada kullanım dok&uuml;manları ve test plan dok&uuml;manları da oluşturulabilir.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li><strong>Tasarım:</strong>&nbsp;Gereksinimlerin tamamlanmasıyla beraber sistem tasarım aşamasına başlanır. Yazılım &uuml;r&uuml;n tasarımı, m&uuml;şterinin gereksinim ve isteklerini karşılamak &uuml;zere yazılım &uuml;r&uuml;n&uuml;n&uuml;n &ouml;zellikleri, yetenekleri, ve aray&uuml;zlerinin belirlenmesi etkinliğidir. İki t&uuml;r tasarımdan bahsetmek m&uuml;mk&uuml;nd&uuml;r (Y&uuml;ksek d&uuml;zeyde tasarım &mdash; Mimari tasarım ve Detaylı tasarım). Mimari tasarım, yazılım mod&uuml;llerinin genel yapıları ve organizasyon i&ccedil;erisindeki etkileşimleri ile ilgilenir. Sonucunda mimari tasarım dok&uuml;manları oluşturulur. Detaylı tasarım aşamasında Mimari tasarım dok&uuml;manları genelde revize edilirler.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>Tasarım ve analiz aşamalarının ayrımı &ldquo;Problem&nbsp;<strong>Ne</strong>?/Problem&nbsp;<strong>Nasıl</strong>&Ccedil;&ouml;z&uuml;l&uuml;r?&rdquo; sorularının kullanımı ile ilgilidir. Gereksinimlerin belirlendiği analiz aşaması problemin ne olduğu ile ilgilidir. Unutmamak gerekir ki sistemdeki t&uuml;m problemler yazılım &uuml;r&uuml;n&uuml;n&uuml;n tamamlanması ile &ccedil;&ouml;z&uuml;lmeyecektir. Maalesef &ccedil;oğu zaman&nbsp;<em>Ne</em>&nbsp;s&ouml;ylemi tasarım kararı olurken&nbsp;<em>Nasıl</em>&nbsp;s&ouml;ylemi de m&uuml;şterinin gereksinimi olabilmektedir. Bu duruma dikkat etmek gerekir.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>Yazılım tasarımında kullanılan en &ouml;nemli tekniklerden birisi&nbsp;<strong>Soyutlama (Abstraction)</strong>&nbsp;dır. Soyutlama, problemlerin &ccedil;&ouml;z&uuml;mlerini kolaylaştırmak i&ccedil;in nesnelerin, olayların ve durumların bazı &ouml;zelliklerin g&ouml;rmezden gelinmesidir. Problemi basitleştirerek en &ouml;nemli kısımlarına odaklanmamızı sağlar.&nbsp;<strong>Modelleme</strong>&nbsp;is temel tasarım aracı olup statik ve dinamik modellerden bahsetmekten m&uuml;mk&uuml;nd&uuml;r. Statik model, programın &ccedil;alışması sırasında değişmeyen y&ouml;nlerini ifade etmek i&ccedil;in kullanılırken (sınıf ve nesne modelleri), dinamik model programın &ccedil;alışması sırasındaki işleyişi ifade etmek i&ccedil;in kullanılır ( durum ve sıra diyagramları).</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li><strong>Ger&ccedil;ekleştirim (Kodlama ve Test)</strong></li>\r\n	<li>Tasarım aşamasının belirli bir olgunluğa ulaşmasıyla birlikte&nbsp;<strong>Kodlama</strong>aşaması başlar. M&uuml;şteriye teslim edilecek &uuml;r&uuml;n&uuml; programlama aşamasıdır. İyi kod, okunabilirliği ve bakımı kolay olan&nbsp;<strong>basit koddur</strong>.&nbsp;<strong>KISS</strong>&nbsp;(Keep it simple) prensibine g&ouml;re yeni mezun olmuş birisine kodunuzu verdiğinde 1&ndash;2 g&uuml;n i&ccedil;erisinde anlayabiliyor ve değiştirebiliyorsa kodunuz iyi bir koddur.&nbsp; İster bir şirkette &ccedil;alışın ister bireysel projeler geliştirin mutlaka belirli bir&nbsp;<strong>kodlama kalite standardınız&nbsp;&nbsp;</strong>olsun (İsimlendirme standartları, yorum satırı kullanımları, tekrar eden kodlar, dev &ndash;if koşul blokları, aşırı benzer işlevler, uzun metotlar vb.)</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>Kodlama s&uuml;resince ve kodlama sonrasında yapılan diğer &ouml;nemli aşama&nbsp;<strong>test&rsquo;tir</strong>. Erken test et yaklaşımı ile (<strong>early testing</strong>) hareket edip, analiz aşamasından itibaren test bakış a&ccedil;ısına sahip olmamız hata yapma oranımızı ve maliyetleri (zaman, para, prestij vb.) d&uuml;ş&uuml;recektir. Birim testleri, duman testleri, yanlış değer testleri, kabul testleri, kullanım senaryo testleri, y&uuml;k testleri, kullanıcı kabul testi,&nbsp; test otomasyonu gibi s&uuml;rece ve duruma g&ouml;re uygulanabilecek &ccedil;ok farklı kategoride ve derinlikte test t&uuml;r&uuml; bulunmaktadır.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li><strong>Teslim ve Bakım</strong></li>\r\n	<li>T&uuml;m test aşamaları tamamlandıktan sonra yazılım &uuml;r&uuml;n&uuml;n sahaya teslim edilebilir bir versiyonu &ccedil;ıkartılır ve teslim aşaması ger&ccedil;ekleştirilir. Teslim &ccedil;ıktısı olarak &uuml;r&uuml;n tek başına yeterli değildir. Mutlaka son kullanıcılar i&ccedil;in kullanım kılavuzu ve versiyon fark dok&uuml;manı oluşturulmalıdır. Teslim ile birlikte bakım aşaması da başlar. Hata giderici, &ouml;nleyici, altyapıyı iyileştirici, &uuml;r&uuml;ne yeni &ouml;zellikler ekletici gibi farklı bakım faaliyetleri mevcuttur.</li>\r\n</ul>\r\n\r\n<p>Yaşam d&ouml;ng&uuml;s&uuml;n&uuml;n temel adımları &ccedil;ekirdek s&uuml;re&ccedil;ler (core processes) olarak da adlandırılır. Bu s&uuml;re&ccedil;lerin ger&ccedil;ekleştirilmesi amacıyla&nbsp;<em>Yazılım</em>&nbsp;<em>S&uuml;re&ccedil; Modelleri</em>&nbsp;kullanılmaktadır.</p>\r\n\r\n<p><strong>Yazılım S&uuml;re&ccedil; Modelleri (Processes)</strong></p>\r\n\r\n<p>Yazılım yaşam d&ouml;ng&uuml;s&uuml;nde belirtilen s&uuml;re&ccedil;lerin geliştirme aşamasında, hangi d&uuml;zen ya da sırada, nasıl uygulanacağını tanımlayan modellerdir. Karmaşıklığı azaltıp krizleri &ouml;nler. &Uuml;r&uuml;nlerin beklenilen kalitede olması s&uuml;re&ccedil;lerin kontrol edilmesine bağlıdır. Belli başlı yazılım s&uuml;re&ccedil; modelleri aşağıdaki gibidir;</p>\r\n\r\n<ul>\r\n	<li>Kodla ve D&uuml;zelt (Code and Fix)</li>\r\n	<li>Şelale Modeli (Waterfall Model)</li>\r\n	<li>V Modeli (V-shaped Model)</li>\r\n	<li>Evrimsel Geliştirme (Evolutionary Development)</li>\r\n	<li>Prototipleme (Prototyping)</li>\r\n	<li>Spiral Model</li>\r\n	<li>Formal Sistem Geliştirme (Formal System Development)</li>\r\n	<li>Yeniden kullanıma y&ouml;nelik geliştirme (Re-use based development)</li>\r\n	<li>Artımlı Geliştirme (Incremental Development)</li>\r\n	<li>Birleşik S&uuml;re&ccedil; (Unified Process)</li>\r\n	<li>&Ccedil;evik Modeller (Agile models: XP,&nbsp;<a data-href=\"https://denizkilinc.com/2013/06/30/scrum-nedir/\" href=\"https://denizkilinc.com/2013/06/30/scrum-nedir/\" rel=\"nofollow noopener\" target=\"_blank\" title=\"Scrum Nedir?\">Scrum</a>)</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '9 Şubat 2019'),
(5, '5-icerik45293-4930', 'Bilgisayar Mantığı', 'Temel olarak bilgisayarı gerçek dünya yansıtmalarıyla anlamamıza olanak sağlayan mantık modelleri içerir.', '<p><strong>Kısaca &ouml;nermeler Mantığı ( Propositional Logic )</strong></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;&Ouml;nermeler , mantık bilimi a&ccedil;ısından &ouml;nemli olan en ufan yapı taşıdır.</p>\r\n\r\n<p>&Ouml;rneğin, &quot;Bug&uuml;n pazartesidir.&quot; c&uuml;mlesi bir &ouml;nermedir. &Ouml;nermelerin zorunlu olarak bir olguya dayandırılması &ouml;nem arz etmez. Bu &ouml;rnekte ger&ccedil;ek hayata dayandırılmıştır.</p>\r\n\r\n<p>&Ouml;nermenin sonucu , &ouml;nerildiği gibi ger&ccedil;ekleşirse &ouml;nermenin sonucu olumludur.Aksi halde yani &ouml;nerildiği gibi sonu&ccedil; vermezse &ouml;nermenin sonucu olumsuzdur.</p>\r\n\r\n<p>Sonu&ccedil; belirtimi:</p>\r\n\r\n<p>Yanlış anlamını veriyorsa mantıksal 0 (logic 0)</p>\r\n\r\n<p>Doğru anlamını veriyorsa mantıksal 1 (logic 1) ile belirtilir.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3><strong>Birinci Derece Mantık (First Order Logic)</strong></h3>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Bilgisayar bilimlerinin de aralarında bulunduğu, matematik ve dilbilim alanlarında kullanılan bir mantık modelidir.</p>\r\n\r\n<p>Bu modelin &ouml;zelliği kıyas ve t&uuml;mden gelim yaklaşımına g&ouml;re ispatlanabilir &ouml;zellikte olmasıdır. Yani matematiksel veya makine modeli tarafından bu mantık modelindeki g&ouml;sterimlerin ispatlanması m&uuml;mk&uuml;nd&uuml;r.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Birinci derece mantıkta sonsuz k&uuml;meler olan doğal sayılar veya kartezyen uzay gibi varlıkların modellenmesi ve &ccedil;&ouml;z&uuml;mlenmesi m&uuml;mk&uuml;n olmamaktadır.</p>\r\n\r\n<p>Bu t&uuml;r sonsuzluk i&ccedil;eren modeller ikinci derece mantık(second order logic) benzeri daha kuvvetli mantık modellemelerinden yararlanmak m&uuml;mk&uuml;nd&uuml;r.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&Ouml;rnek: &quot;Cansu &ouml;ğrencidir.&quot; C&uuml;mlesi klasik bir &ouml;nermedir. kalsik mantık a&ccedil;ısından&nbsp;doğru veya yanlıştır.</p>\r\n\r\n<p>Benzer şekilde &quot;Yusuf &ouml;ğrencidir&quot; c&uuml;mleside bir mantıksal &ouml;nermedir. Tek başına ele alınarak doğruluğu veya yanlışlığı ile değerlendirilebilir.</p>\r\n\r\n<p>p &rarr; q (Cansu &ouml;ğreci ise Yusuf &ouml;ğrencidir)</p>\r\n\r\n<p>p &and; q (Cansu ve Yusuf &ouml;ğrencidir)</p>\r\n\r\n<p>p&nbsp;&or; q (Cansu veya Yusuf &Ouml;ğrencidir)</p>\r\n\r\n<p>&not;&nbsp; p (Cansu &Ouml;ğrenci değildir)</p>\r\n\r\n<p>Birinci derece mantık yukarıda verilen bu &ouml;nermeleri &ouml;ncelikle niceleyiciler &uuml;zerine taşır. Bu niceleyiciler bilgisayar bilimlerinde basitce değişkenler olarak d&uuml;ş&uuml;n&uuml;lebilir.</p>\r\n\r\n<p>Birinci derece mantığa g&ouml;re :</p>\r\n\r\n<p>Cansu (M) =&gt; &Ouml;ğrenci (M)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Bu model okunurken &quot;&ouml;yle bir &#39;M&#39; vardır ki bu &#39;M&#39; nin ismi&nbsp;Cansudu ve bu &#39;M&#39; &ouml;ğrencidir&quot; şeklinde okunabilir. Birinci derece mantıkta sorulabilen ve aynı zamanda klasik mantık a&ccedil;ısından sorulamayan &quot;Bu M nasıl bir &#39;M&#39; dir?&quot; sorusudur.</p>\r\n\r\n<p>Bu birinci derecenin farklarını ortaya koyan iki &ouml;nemli sembol vardır.</p>\r\n\r\n<p>Bunlardan birincisi &ldquo;her&rdquo; anlamına gelen (&forall;) sembol iken diğeri &ldquo;&ouml;yle bazı&rdquo; şeklinde okunabilecek (&exist;) sembold&uuml;r.</p>\r\n\r\n<p>&exist;M&nbsp;(CAnsu(M)&nbsp;&and; &ouml;ğrenci(M))&nbsp;&rarr; &Ouml;yle bazı M&rsquo;lar vardır ki, bu M&rsquo;nin ismi Cansu&rsquo;dur ve bu M&nbsp;&ouml;ğrencidir.</p>\r\n\r\n<p>&forall;M&nbsp;(&Uuml;niversite &ouml;ğrencisi (M)&nbsp;&rArr; &ouml;ğrencisi(M)) &rarr; B&uuml;t&uuml;n M&rsquo;ler i&ccedil;in, M&nbsp;şayet &Uuml;niversite &ouml;ğrencisi ise; M, aynı zamanda bir &ouml;ğrencidir.</p>\r\n\r\n<p>Yine, yukarıdaki g&ouml;sterim kullanılarak s&ouml;ylenebilecek doğru bir model de aşağıdaki gibi olabilir:</p>\r\n\r\n<p>&exist;M&nbsp;(Cansu&nbsp;(M)&nbsp;&and;&nbsp;&not; &ouml;ğrenci(M)) &rarr; &Ouml;yle bazı M&rsquo;ler vardır ki, bu M&rsquo;nin ismi Cansu&rsquo;dur ve bu M &ouml;ğrenci&nbsp;değildir.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>&nbsp;</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '17 Şubat 2019'),
(18, '18-icerik85042-85446', 'Payidar topluluğunun Rent a Car Çözümü', 'Payidar Topluluğunun bir üyesi olarak rent a car çözümüne yeni bir bakış açısı kazandırmak takım çalışması olarak kayda değer bir ilerleme oldu.', '<p>Rent A Car denince aklımıza gelen , ara&ccedil; kiralamak i&ccedil;in kiralama firmasına başvuran m&uuml;şterinin kayıtlarını tutan ve firmaya bağlı olarak senet işlemleri yapan bir program gelir akla.</p>\r\n\r\n<p>Payidar topluluğu olarak rent a car firmalarının uzun s&uuml;ren&nbsp; s&ouml;zleşme fasıllarını&nbsp; daha kısa zaman aralıklarına d&uuml;ş&uuml;rmekten tutunda , m&uuml;şteri kimlik kontrollerine kadar yazılım &ccedil;&ouml;z&uuml;m&uuml;nde aranan &ouml;zelliklerin barındığı bir proje yapılmış oldu.</p>\r\n\r\n<p><strong>Peki nedir bu Rent a car &Ccedil;&ouml;z&uuml;m&uuml; ?</strong></p>\r\n\r\n<p>Alışıla gelen rent a car gereksinimlerinin&nbsp;yanı sıra ekstra&nbsp;istenen ve &ouml;ng&ouml;r&uuml;len fonksiyonlarıda barındıran bir ara&ccedil; kiralama yazılımıdır.</p>\r\n\r\n<p>Sistemin b&uuml;t&uuml;n fonksiyon ve işlevlerinden bahsetmek yerine bilindik fonsiyon ve kayda değer farklılıklarından bahsetmek daha iyi olur diye d&uuml;ş&uuml;n&uuml;yorum.</p>\r\n\r\n<p>Bu rent a car &ccedil;&ouml;z&uuml;m&uuml;m&uuml;z de rent a car d&uuml;nyasında m&uuml;şterilerin firmadan beklentileri ve aynı şekilde firmanında kar amacı ve m&uuml;şteri memnuniyeti g&ouml;zeterek ortaya koyduğu gereksinimleri karşılamak hedeflenmiştir.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>A&ccedil;ıklama : YETSOFT logosu &ouml;rnek logo konumudur.</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/17110337.png\" style=\"height:626px; width:800px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; Şekil 1 - Ara&ccedil; kiralama yazılımı ana men&uuml; g&ouml;r&uuml;n&uuml;m&uuml;.</p>\r\n\r\n<p>Şekil 1 de G&ouml;r&uuml;ld&uuml;ğ&uuml; gibi ara&ccedil; kiralama sisteminin ana gereksinimleri yerine getirilmiştir. Bu doğrultuda kullanıcının işlemlerini yazılım &uuml;zerinde tek tık&#39;ı ama&ccedil;alayarak tasarlanmış bir aray&uuml;z&uuml; mevcuttur.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Yazılımda gereksinim evresinde belirlenmiş olan ara&ccedil; kiralama evrelerinde ;</p>\r\n\r\n<ul>\r\n	<li>İkinci şof&ouml;r &ouml;zelliği,</li>\r\n	<li>Fatura g&ouml;nderimi,</li>\r\n	<li>Ekstralar sekmesi (daha ayrıntılı bahsedeceğim),</li>\r\n	<li>S&ouml;zleşme evresi ara&ccedil; değişimi olanağı (her iki taraf anlaşmalı olarak).</li>\r\n</ul>\r\n\r\n<p>Gibi &ouml;nemli ayrıntılara yazılım &ccedil;&ouml;z&uuml;m&uuml;nde yer verildi.</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/193c1b2a.png\" style=\"height:513px; width:706px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; şekil 2 - Ara&ccedil; kiralama s&ouml;zleşme ekranı.</p>\r\n\r\n<p>Ara&ccedil; kiralama s&ouml;zleşmesi esasına dayalı olarak kiraya veren mecra tarafından doldurulan ;</p>\r\n\r\n<ul>\r\n	<li>M&uuml;şteri bilgileri (veri tabanında kayıtlı ise oradan se&ccedil;ilir) doldurulur ,</li>\r\n	<li>İstenilen ara&ccedil; bilgileri,</li>\r\n	<li>Kiralama zaman aralığı,</li>\r\n	<li>Daha &ouml;nceki km bilgileri,</li>\r\n	<li>&Ouml;deme t&uuml;r&uuml; ,</li>\r\n	<li>İkinci Şof&ouml;r.</li>\r\n</ul>\r\n\r\n<p>bilgileri gibi bilgi girişleri yer almaktadır.</p>\r\n\r\n<p>Bunun yanı sıra ara&ccedil; kiralamak isteyen ger&ccedil;ek veya t&uuml;zel kişilere de ekstra hizmetler sunmaktadır.</p>\r\n\r\n<p><img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/20198aee.png\" style=\"height:199px; width:557px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Şekil 3 - Eksra&nbsp; hizmet ekranı</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Şekil 3 &#39;de kiralama yapan tarafın kiralama şirketinden taleb edebileceği ayrı hizmetleri i&ccedil;erir.</p>\r\n\r\n<p>Şirketin belirlediği &uuml;cret miktarları hizmet t&uuml;rn&uuml;n yanındaki textbox&#39;a girilir ve g&uuml;n sayısı ile sistem tarafından hesaplanır.</p>\r\n\r\n<p>&nbsp;</p>\r\n', '17 Şubat 2019'),
(19, 'fotomuh-icerik38359-5467', 'Regresyon Analizi', 'İstatistiklerde, doğrusal regresyon, skaler bir yanıt (veya bağımlı değişken) ile bir veya daha fazla açıklayıcı değişken (veya bağımsız değişkenler) arasındaki ilişkiyi modellemeye yönelik doğrusal bir yaklaşımdır.', '<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Doğrusal resgrasyon analizi , belirlenmek istenen değişkenden daha kolay saptanabilen değişkenlerden yola &ccedil;ıkarak belirlenmek istenen değişkeni tahmin eden bir model&nbsp; oluşturmaktadır.</p>\r\n\r\n<p>İnsanlar &uuml;zerinden &ouml;rnekleyecek olursak ;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hamilton depresyon puanını hesaplamayı ama&ccedil;lıyoruz ve bu işi hastaya ilgili &ouml;l&ccedil;eği uygulamadan &ouml;zl&uuml;k bilgilerini kullanarak (yaşı , v&uuml;cut kitle indeksi,kortizol seviyesi) doğru değerlere yakın bir d&uuml;zeyde tahmin etmek ama&ccedil;lanır.</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bilinen ve normal eğilim g&ouml;steren bir değişkenden,&nbsp; aralarında ilişki olan başka bir normal eğilim g&ouml;steren sayısal değeri tahmin etmek i&ccedil;in uygulanırsa<strong> doğrusal regresyon modeli&nbsp;</strong>,</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<blockquote>\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; <img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/24e6ad15.png\" style=\"height:60px; width:300px\" />&nbsp; &nbsp; &nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Doğrusal regresyon modeli&nbsp;</p>\r\n</blockquote>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\r\n\r\n<p>birden&nbsp; fazla tahmin değişkeni i&ccedil;eren doğrusal regresyon modeline <strong>&ccedil;oklu doğrusal regresyon modeli</strong> denir.</p>\r\n\r\n<blockquote>\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/24e6ad15.png\" style=\"height:60px; width:300px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &Ccedil;oklu regresyon modeli.</p>\r\n</blockquote>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\r\n\r\n<h2><strong>&nbsp;Polinomik regresyon&nbsp;</strong></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Bazen, veriler arasında doğrusal olmayan bir ilişki olabilir. B&ouml;yle bir ilişkiyi a&ccedil;ıklamaya &ccedil;alışmanın bir yolu, bir polinom regresyon modelidir. Veri&nbsp; analizinde tahminlerin ve analizlerin ger&ccedil;eğe daha yakın sonu&ccedil; vermesi beklendiğinde polinomik regresyon kullanılır. &Ouml;rnek kullanım i&ccedil;in basit bir paylaşım mevcut &ouml;ncelikle tek bir tahmini X i&ccedil;in b&ouml;yle bir model:&nbsp;</p>\r\n\r\n<blockquote>\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt=\"\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/272702ca.png\" style=\"height:50px; width:300px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Polinomik regresyon modeli.</p>\r\n</blockquote>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt=\"Polinomik regresyon modeli\" src=\"http://127.0.1.1/workblog/AdminInterface/html/ltr/ckeditor/plugins/imageuploader/uploads/284ef2bf.png\" style=\"height:258px; width:475px\" /></p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Polinomik regresyon modeli</p>\r\n\r\n<p>Polinomik regresyon modelinin kod &ouml;rneği&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">import pandas as pd\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\ndf=pd.read_csv(\"polynomial-regression.csv\", sep=\";\")\r\n\r\ny=df.araba_max_hiz.values.reshape(-1,1)\r\nx=df.araba_fiyat.values.reshape(-1,1)\r\n\r\nplt.scatter(x,y)\r\nplt.xlabel(\"Fiyat\")\r\nplt.ylabel(\"Hız\")\r\n\r\n\r\n#linear regression \r\nfrom sklearn.linear_model import LinearRegression\r\n\r\nlr=LinearRegression()\r\nlr.fit(x,y)\r\n\r\n#predict\r\n\r\ny_head=lr.predict(x)\r\nplt.plot(x,y_head,color=\"red\")\r\n\r\n\r\n#polinomial regression (polinomik regresyon gösterimi)\r\n\r\nfrom sklearn.preprocessing import PolynomialFeatures\r\npolinomial_regression=PolynomialFeatures(degree = 4)\r\nx_polinomial=polinomial_regression.fit_transform(x)\r\n\r\nlinear_regression2=LinearRegression()\r\nlinear_regression2.fit(x_polinomial,y)\r\n\r\ny_head2=linear_regression2.predict(x_polinomial)\r\nplt.plot(x,y_head2,color=\"green\" , label=\"poly\")\r\nplt.legend()\r\nplt.show()\r\n\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '27 Şubat 2019'),
(20, '20-icerik23929-6571', 'Veri Görselleştirme (Data Visualization)', '', '<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Veri g&ouml;rselleştirme, verileri g&ouml;rsel bir bağlamda yerleştirerek anlamaya &ccedil;alışmanın disiplinidir, b&ouml;ylece başka t&uuml;rl&uuml; tespit edilemeyen kalıplar, eğilimler ve korelasyonlar ortaya &ccedil;ıkabilir. Python, bir&ccedil;ok farklı &ouml;zellik i&ccedil;eren &ccedil;ok sayıda harika grafik k&uuml;t&uuml;phanesi sunar. İnteraktif, canlı veya &ccedil;ok &ouml;zel kişiselleştirilmiş grafikler oluşturmak i&ccedil;in , python k&uuml;t&uuml;phane sunmaktadır.</p>\r\n\r\n<p>Burada genel olarak bakarsak birka&ccedil; pop&uuml;ler &ccedil;izim k&uuml;t&uuml;phane bulunmaktadır :</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p><strong><ins>Plotly</ins></strong> :&nbsp; Bu k&uuml;t&uuml;phane etkileşimli &ccedil;izim olanakları sunar,</p>\r\n	</li>\r\n	<li>\r\n	<p><ins><strong>Matplotlib</strong></ins> : D&uuml;ş&uuml;k seviyede, bol miktarda &ccedil;izim olanağı sunar,</p>\r\n	</li>\r\n	<li>\r\n	<p><ins><strong>Pandas Visualization</strong></ins> : Matplotlib &uuml;zerinde kurulu ve kullanımı kolaydır,&nbsp;</p>\r\n	</li>\r\n	<li>\r\n	<p><ins><strong>Seaborn</strong></ins> : Y&uuml;ksek Seviye aray&uuml;z&uuml; ve gelişmiş varsayılan stillere sahip bir k&uuml;t&uuml;phanedir.</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '5 Mart 2019');

--
-- Dökümü yapılmış tablolar için indeksler
--

--
-- Tablo için indeksler `haftalikyayin`
--
ALTER TABLE `haftalikyayin`
  ADD PRIMARY KEY (`konuid`);

--
-- Tablo için indeksler `icerik`
--
ALTER TABLE `icerik`
  ADD PRIMARY KEY (`icerikID`);

--
-- Tablo için indeksler `iletisimkullanici`
--
ALTER TABLE `iletisimkullanici`
  ADD PRIMARY KEY (`mesID`);

--
-- Tablo için indeksler `kullanicilar`
--
ALTER TABLE `kullanicilar`
  ADD PRIMARY KEY (`kulid`);

--
-- Tablo için indeksler `muhsekme`
--
ALTER TABLE `muhsekme`
  ADD PRIMARY KEY (`icerikId`);

--
-- Dökümü yapılmış tablolar için AUTO_INCREMENT değeri
--

--
-- Tablo için AUTO_INCREMENT değeri `haftalikyayin`
--
ALTER TABLE `haftalikyayin`
  MODIFY `konuid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;

--
-- Tablo için AUTO_INCREMENT değeri `icerik`
--
ALTER TABLE `icerik`
  MODIFY `icerikID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=30;

--
-- Tablo için AUTO_INCREMENT değeri `iletisimkullanici`
--
ALTER TABLE `iletisimkullanici`
  MODIFY `mesID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=18;

--
-- Tablo için AUTO_INCREMENT değeri `kullanicilar`
--
ALTER TABLE `kullanicilar`
  MODIFY `kulid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- Tablo için AUTO_INCREMENT değeri `muhsekme`
--
ALTER TABLE `muhsekme`
  MODIFY `icerikId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=21;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
